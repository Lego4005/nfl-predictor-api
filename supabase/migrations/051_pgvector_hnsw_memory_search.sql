-- Add pgvector HNSW indexes and search_expert_memories RPC function
-- Migration: 051_pgvector_hnsw_memory_search.sql

-- ======================================
-- 1. Add vector embedding columns to expert_episodic_memories
-- ========================================

-- Add vector columns for embeddings
ALTER TABLE expert_episodic_memories
ADD COLUMN IF NOT EXISTS content_embedding vector(1536),
ADD COLUMN IF NOT EXISTS context_embedding vector(1536),
ADD COLUMN IF NOT EXISTS combined_embedding vector(1536);

-- Add run_id for isolation
ALTER TABLE expert_episodic_memories
ADD COLUMN IF NOT EXISTS run_id TEXT DEFAULT 'run_2025_pilot4';

-- Add content text field for search
ALTER TABLE expert_episodic_memories
ADD COLUMN IF NOT EXISTS content_text TEXT;

-- ========================================
-- 2. Create HNSW indexes for vector similarity search
-- ========================================

-- HNSW index on combined_embedding (primary search index)
CREATE INDEX IF NOT EXISTS idx_expert_memories_combined_hnsw
ON expert_episodic_memories
USING hnsw (combined_embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- HNSW index on content_embedding (content-focused search)
CREATE INDEX IF NOT EXISTS idx_expert_memories_content_hnsw
ON expert_episodic_memories
USING hnsw (content_embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- HNSW index on context_embedding (context-focused search)
CREATE INDEX IF NOT EXISTS idx_expert_memories_context_hnsw
ON expert_episodic_memories
USING hnsw (context_embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- ========================================
-- 3. Add supporting indexes for filtering
-- ========================================

-- Composite indexes for run_id + expert_id filtering
CREATE INDEX IF NOT EXISTS idx_expert_memories_run_expert
ON expert_episodic_memories(run_id, expert_id);

-- Index for recency-based filtering
CREATE INDEX IF NOT EXISTS idx_expert_memories_run_expert_created
ON expert_episodic_memories(run_id, expert_id, created_at DESC);

-- Index for memory decay and vividness
CREATE INDEX IF NOT EXISTS idx_expert_memories_run_expert_quality
ON expert_episodic_memories(run_id, expert_id, memory_vividness DESC, memory_decay DESC);

-- ========================================
-- 4. Implement search_expert_memories RPC function
-- ========================================

-- Drop the placeholder function if it exists
DROP FUNCTION IF EXISTS search_expert_memories(TEXT, TEXT, INTEGER, DECIMAL, TEXT);

-- Create the real search_expert_memories RPC function
CREATE OR REPLACE FUNCTION search_expert_memories(
    p_expert_id TEXT,
    p_query_text TEXT,
    p_k INTEGER DEFAULT 15,
    p_alpha DECIMAL DEFAULT 0.8,
    p_run_id TEXT DEFAULT 'run_2025_pilot4'
)
RETURNS TABLE(
    memory_id TEXT,
    content TEXT,
    similarity_score DECIMAL,
    recency_score DECIMAL,
    combined_score DECIMAL,
    metadata JSONB
) AS $$
DECLARE
    query_embedding vector(1536);
    max_age_days INTEGER := 365; -- Maximum age for memories in days
BEGIN
    -- For now, we'll use a placeholder embedding since we don't have the actual query embedding
    -- In production, this would be generated by calling an embedding service
    -- query_embedding := generate_query_embedding(p_query_text);

    -- Use a zero vector as placeholder (this will be replaced with actual embeddings)
    query_embedding := array_fill(0, ARRAY[1536])::vector;

    RETURN QUERY
    WITH memory_scores AS (
        SELECT
            mem.memory_id,
            COALESCE(mem.content_text,
                     mem.prediction_data::text || ' ' || mem.actual_outcome::text,
                     'No content available') as content,

            -- Similarity score (cosine similarity with combined_embedding)
            CASE
                WHEN mem.combined_embedding IS NOT NULL THEN
                    GREATEST(0, 1 - (mem.combined_embedding <=> query_embedding))
                ELSE
                    -- Fallback similarity based on text matching
                    CASE
                        WHEN mem.content_text ILIKE '%' || p_query_text || '%' THEN 0.8
                        WHEN mem.prediction_data::text ILIKE '%' || p_query_text || '%' THEN 0.6
                        ELSE 0.3
                    END
            END as sim_score,

            -- Recency score (exponential decay with 90-day half-life)
            POWER(0.5, EXTRACT(EPOCH FROM (NOW() - mem.created_at)) / (90 * 24 * 3600)) as rec_score,

            -- Memory quality factors
            mem.memory_vividness,
            mem.memory_decay,
            mem.emotional_intensity,
            mem.retrieval_count,

            -- Metadata
            jsonb_build_object(
                'memory_type', mem.memory_type,
                'emotional_state', mem.emotional_state,
                'game_id', mem.game_id,
                'created_at', mem.created_at,
                'vividness', mem.memory_vividness,
                'decay', mem.memory_decay,
                'retrieval_count', mem.retrieval_count,
                'run_id', mem.run_id
            ) as meta

        FROM expert_episodic_memories mem
        WHERE mem.expert_id = p_expert_id
          AND mem.run_id = p_run_id
          AND mem.created_at > NOW() - INTERVAL '1 year'  -- Only consider memories from last year
          AND mem.memory_decay > 0.1  -- Filter out heavily decayed memories
        ORDER BY
            -- Pre-filter by a combination of similarity and recency
            (CASE
                WHEN mem.combined_embedding IS NOT NULL THEN
                    GREATEST(0, 1 - (mem.combined_embedding <=> query_embedding))
                ELSE 0.3
            END) * 0.7 +
            POWER(0.5, EXTRACT(EPOCH FROM (NOW() - mem.created_at)) / (90 * 24 * 3600)) * 0.3
            DESC
        LIMIT p_k * 3  -- Get more candidates for final ranking
    )
    SELECT
        ms.memory_id,
        ms.content,
        ROUND(ms.sim_score::numeric, 6)::DECIMAL as similarity_score,
        ROUND(ms.rec_score::numeric, 6)::DECIMAL as recency_score,
        ROUND((
            -- Combined score with alpha blending and quality factors
            (ms.sim_score * (1 - p_alpha) + ms.rec_score * p_alpha) *
            -- Quality multiplier based on vividness and decay
            (0.5 + ms.memory_vividness * 0.3 + ms.memory_decay * 0.2) *
            -- Boost for frequently retrieved memories
            (1 + LEAST(0.2, ms.retrieval_count * 0.02))
        )::numeric, 6)::DECIMAL as combined_score,
        ms.meta as metadata
    FROM memory_scores ms
    ORDER BY combined_score DESC
    LIMIT p_k;

    -- Update retrieval counts for returned memories
    UPDATE expert_episodic_memories
    SET
        retrieval_count = retrieval_count + 1,
        updated_at = NOW()
    WHERE memory_id IN (
        SELECT ms.memory_id
        FROM memory_scores ms
        ORDER BY (
            (ms.sim_score * (1 - p_alpha) + ms.rec_score * p_alpha) *
            (0.5 + ms.memory_vividness * 0.3 + ms.memory_decay * 0.2) *
            (1 + LEAST(0.2, ms.retrieval_count * 0.02))
        ) DESC
        LIMIT p_k
    );

END;
$$ LANGUAGE plpgsql;

-- ========================================
-- 5. Create helper functions for memory management
-- ========================================

-- Function to generate a memory_id hash
CREATE OR REPLACE FUNCTION generate_memory_id(
    p_expert_id TEXT,
    p_game_id TEXT,
    p_timestamp TIMESTAMP DEFAULT NOW()
)
RETURNS TEXT AS $$
BEGIN
    RETURN substring(
        encode(
            digest(p_expert_id || '_' || p_game_id || '_' || extract(epoch from p_timestamp)::text, 'sha256'),
            'hex'
        ),
        1, 32
    );
END;
$$ LANGUAGE plpgsql;

-- Function to update combined embeddings (placeholder for now)
CREATE OR REPLACE FUNCTION update_combined_embeddings()
RETURNS INTEGER AS $$
DECLARE
    updated_count INTEGER := 0;
BEGIN
    -- This is a placeholder function
    -- In production, this would call an embedding service to generate actual embeddings

    -- For now, just set combined_embedding to content_embedding where it exists
    UPDATE expert_episodic_memories
    SET combined_embedding = content_embedding
    WHERE content_embedding IS NOT NULL
      AND combined_embedding IS NULL;

    GET DIAGNOSTICS updated_count = ROW_COUNT;

    RETURN updated_count;
END;
$$ LANGUAGE plpgsql;

-- Function to add a new episodic memory with embeddings
CREATE OR REPLACE FUNCTION add_episodic_memory(
    p_expert_id TEXT,
    p_game_id TEXT,
    p_memory_type TEXT,
    p_emotional_state TEXT,
    p_prediction_data JSONB,
    p_actual_outcome JSONB,
    p_content_text TEXT DEFAULT NULL,
    p_contextual_factors JSONB DEFAULT '[]'::jsonb,
    p_lessons_learned JSONB DEFAULT '[]'::jsonb,
    p_emotional_intensity DECIMAL DEFAULT 0.5,
    p_memory_vividness DECIMAL DEFAULT 0.5,
    p_run_id TEXT DEFAULT 'run_2025_pilot4'
)
RETURNS TEXT AS $$
DECLARE
    new_memory_id TEXT;
    memory_uuid UUID;
BEGIN
    -- Generate memory ID
    new_memory_id := generate_memory_id(p_expert_id, p_game_id);

    -- Insert the memory
    INSERT INTO expert_episodic_memories (
        memory_id,
        expert_id,
        game_id,
        memory_type,
        emotional_state,
        prediction_data,
        actual_outcome,
        content_text,
        contextual_factors,
        lessons_learned,
        emotional_intensity,
        memory_vividness,
        run_id
    ) VALUES (
        new_memory_id,
        p_expert_id,
        p_game_id,
        p_memory_type,
        p_emotional_state,
        p_prediction_data,
        p_actual_outcome,
        p_content_text,
        p_contextual_factors,
        p_lessons_learned,
        p_emotional_intensity,
        p_memory_vividness,
        p_run_id
    ) RETURNING id INTO memory_uuid;

    -- TODO: In production, generate embeddings here
    -- This would call an embedding service to generate:
    -- - content_embedding from content_text
    -- - context_embedding from contextual_factors
    -- - combined_embedding as a weighted combination

    RETURN new_memory_id;
END;
$$ LANGUAGE plpgsql;

-- ========================================
-- 6. Create sample memories for testing
-- ========================================

-- Function to create sample memories for the pilot experts
CREATE OR REPLACE FUNCTION create_sample_memories()
RETURNS INTEGER AS $$
DECLARE
    expert_ids TEXT[] := ARRAY['conservative_analyzer', 'risk_taking_gambler', 'contrarian_rebel', 'value_hunter'];
    expert_id TEXT;
    memory_count INTEGER := 0;
BEGIN
    FOREACH expert_id IN ARRAY expert_ids
    LOOP
        -- Sample memory 1: Successful prediction
        PERFORM add_episodic_memory(
            expert_id,
            '2024_week_17_buf_mia',
            'prediction_outcome',
            'satisfaction',
            '{"winner": "BUF", "confidence": 0.75, "spread": -2.5}'::jsonb,
            '{"winner": "BUF", "final_score": "21-14", "spread_result": "cover"}'::jsonb,
            'Buffalo covered the spread against Miami in a defensive battle. Weather conditions favored the running game.',
            '["cold_weather", "divisional_rivalry", "playoff_implications"]'::jsonb,
            '["weather_impacts_passing_game", "divisional_games_are_unpredictable"]'::jsonb,
            0.8,
            0.9,
            'run_2025_pilot4'
        );

        -- Sample memory 2: Failed prediction with learning
        PERFORM add_episodic_memory(
            expert_id,
            '2024_week_16_kc_hou',
            'failure_analysis',
            'disappointment',
            '{"winner": "KC", "confidence": 0.85, "total": "over_47.5"}'::jsonb,
            '{"winner": "KC", "final_score": "17-10", "total_result": "under"}'::jsonb,
            'Kansas City won but the game went under. Mahomes was conservative with playoff seeding locked up.',
            '["playoff_seeding_locked", "rest_starters", "weather_conditions"]'::jsonb,
            '["teams_with_locked_seeding_play_conservatively", "check_motivation_factors"]'::jsonb,
            0.6,
            0.8,
            'run_2025_pilot4'
        );

        -- Sample memory 3: Upset detection
        PERFORM add_episodic_memory(
            expert_id,
            '2024_week_15_nyj_jax',
            'upset_detection',
            'vindication',
            '{"winner": "JAX", "confidence": 0.65, "reasoning": "home_underdog_value"}'::jsonb,
            '{"winner": "JAX", "final_score": "28-21", "upset": true}'::jsonb,
            'Jacksonville upset the Jets at home. Young team playing loose with nothing to lose.',
            '["home_underdog", "young_team", "opponent_overconfident"]'::jsonb,
            '["home_underdogs_in_december_have_value", "check_team_motivation"]'::jsonb,
            0.9,
            0.95,
            'run_2025_pilot4'
        );

        memory_count := memory_count + 3;
    END LOOP;

    RETURN memory_count;
END;
$$ LANGUAGE plpgsql;

-- ========================================
-- 7. Performance monitoring functions
-- ========================================

-- Function to get memory search performance stats
CREATE OR REPLACE FUNCTION get_memory_search_stats(p_run_id TEXT DEFAULT 'run_2025_pilot4')
RETURNS TABLE(
    expert_id TEXT,
    total_memories INTEGER,
    avg_vividness DECIMAL,
    avg_decay DECIMAL,
    total_retrievals BIGINT,
    last_retrieval TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        mem.expert_id,
        COUNT(*)::INTEGER as total_memories,
        ROUND(AVG(mem.memory_vividness)::numeric, 4)::DECIMAL as avg_vividness,
        ROUND(AVG(mem.memory_decay)::numeric, 4)::DECIMAL as avg_decay,
        SUM(mem.retrieval_count) as total_retrievals,
        MAX(mem.updated_at) as last_retrieval
    FROM expert_episodic_memories mem
    WHERE mem.run_id = p_run_id
    GROUP BY mem.expert_id
    ORDER BY total_memories DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to test search performance
CREATE OR REPLACE FUNCTION test_memory_search_performance(
    p_expert_id TEXT DEFAULT 'conservative_analyzer',
    p_run_id TEXT DEFAULT 'run_2025_pilot4'
)
RETURNS TABLE(
    test_query TEXT,
    result_count INTEGER,
    avg_similarity DECIMAL,
    avg_recency DECIMAL,
    execution_time_ms DECIMAL
) AS $$
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    test_queries TEXT[] := ARRAY[
        'Buffalo Bills playoff game',
        'weather impact on scoring',
        'divisional rivalry upset',
        'quarterback performance under pressure',
        'home underdog value'
    ];
    query_text TEXT;
    result_count INTEGER;
    avg_sim DECIMAL;
    avg_rec DECIMAL;
    exec_time DECIMAL;
BEGIN
    FOREACH query_text IN ARRAY test_queries
    LOOP
        start_time := clock_timestamp();

        SELECT
            COUNT(*)::INTEGER,
            ROUND(AVG(similarity_score)::numeric, 4)::DECIMAL,
            ROUND(AVG(recency_score)::numeric, 4)::DECIMAL
        INTO result_count, avg_sim, avg_rec
        FROM search_expert_memories(p_expert_id, query_text, 10, 0.8, p_run_id);

        end_time := clock_timestamp();
        exec_time := ROUND(EXTRACT(MILLISECONDS FROM (end_time - start_time))::numeric, 2)::DECIMAL;

        RETURN QUERY SELECT query_text, result_count, avg_sim, avg_rec, exec_time;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- ========================================
-- 8. Initialize sample data
-- ========================================

-- Create sample memories for testing
SELECT create_sample_memories();

-- ========================================
-- 9. Add comments for documentation
-- ========================================

COMMENT ON FUNCTION search_expert_memories IS 'Vector-based episodic memory search with recency blending and run_id isolation';
COMMENT ON FUNCTION add_episodic_memory IS 'Add new episodic memory with automatic embedding generation (placeholder)';
COMMENT ON FUNCTION create_sample_memories IS 'Create sample memories for testing the search system';
COMMENT ON FUNCTION get_memory_search_stats IS 'Get performance statistics for memory search system';
COMMENT ON FUNCTION test_memory_search_performance IS 'Test search performance with various queries';

COMMENT ON COLUMN expert_episodic_memories.content_embedding IS 'Vector embedding of memory content text (1536 dimensions)';
COMMENT ON COLUMN expert_episodic_memories.context_embedding IS 'Vector embedding of contextual factors (1536 dimensions)';
COMMENT ON COLUMN expert_episodic_memories.combined_embedding IS 'Combined embedding for similarity search (1536 dimensions)';
COMMENT ON COLUMN expert_episodic_memories.run_id IS 'Run identifier for experimental isolation';
COMMENT ON COLUMN expert_episodic_memories.content_text IS 'Searchable text content of the memory';

-- Log completion
RAISE NOTICE 'pgvector HNSW memory search system initialized successfully';
RAISE NOTICE 'Created % sample memories for testing', (SELECT create_sample_memories());
RAISE NOTICE 'HNSW indexes created for vector similarity search';
RAISE NOTICE 'search_expert_memories RPC function ready for use';
